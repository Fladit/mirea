#lang racket
(define (first_task)
(define return_value empty)
(define first_list (list 1.5 2 3 4 5))
(define second_list (list 6 7 8 9 10))
  (display "first argument of first list is ")
  (display (first first_list))
(if (integer? (first first_list)) (if  (> (first first_list) 0) (set! return_value second_list)(set! return_value (list (first second_list) (last first_list))))
  (set! return_value (list (first second_list) (last first_list))))
 (newline)
 (display "return value is ")
  return_value)

(define (abs value)
  (if (< value 0) (set! value (* value -1)) (value))
  value)

(define (second_task)
(define return_value 0)
(define first_list (list 1 2 3 4 (list 1 2 3)))
  (display "last argument is ")
  (display (last first_list))
(if (number? (last first_list)) (set! return_value (sqrt(abs(last first_list)))) (set! return_value (last first_list)))
 (newline)
 (display "return value is ")
  return_value)

(define (fifth_task)
(define first_point (cons -3 5))
(define second_point (cons 4 6))
  (display "first point is ")
  (display first_point)
  (newline)
  (display "second point is ")
  (display second_point)
  (newline)
(define distance 0)
  (set! distance (sqrt(+ (sqr(-(car second_point)(car first_point))) (sqr(- (cdr second_point) (cdr first_point))))))
  (display "Distance is ")
  distance)



(display "Введите 1 для вызова решения первого задания , 2 для вызова решения второго задания, 3 для вызова решения третьего задания.")
(newline)
(define answer (read))
(if (equal? answer 1) (first_task)
(if (equal? answer 2) (second_task)
(if (equal? answer 3) (fifth_task) (display "Введено неверное значение"))))
